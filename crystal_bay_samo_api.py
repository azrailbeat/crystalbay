"""
–ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è SAMO API –¥–ª—è Crystal Bay Travel
–û—Å–Ω–æ–≤–∞–Ω–∞ –Ω–∞ –æ—Ñ–∏—Ü–∏–∞–ª—å–Ω–æ–π –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏: https://dokuwiki.samo.ru/doku.php?id=onlinest:api
"""
import logging
import requests
import json
from datetime import datetime, timedelta
from typing import Dict, List, Optional, Any
from crystal_bay_samo_api_helpers import handle_error_response

logger = logging.getLogger(__name__)

class CrystalBaySamoAPI:
    """–ü–æ–ª–Ω–∞—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è SAMO API –¥–ª—è Crystal Bay Travel"""
    
    def __init__(self, base_url: Optional[str] = None, oauth_token: Optional[str] = None):
        # Load settings from database/memory
        try:
            from models import SettingsService
            self.settings_service = SettingsService()
            settings = self.settings_service.get_samo_settings()
            
            self.base_url = base_url or settings.get('api_url', 'https://booking.crystalbay.com/export/default.php')
            self.oauth_token = oauth_token or settings.get('oauth_token', '27bd59a7ac67422189789f0188167379')
            
            logger.info(f"üîß SAMO API CONFIG: URL={self.base_url}")
            logger.info(f"üîß OAuth Token: {self.oauth_token[:8]}***{self.oauth_token[-4:] if self.oauth_token else 'None'}")
            self.timeout = int(settings.get('timeout', 30))
            self.user_agent = settings.get('user_agent', 'Crystal Bay Travel Integration/1.0')
        except ImportError:
            # Fallback if models not available
            self.base_url = base_url or "https://booking.crystalbay.com/export/default.php"
            self.oauth_token = oauth_token or "27bd59a7ac67422189789f0188167379"
            self.timeout = 30
            self.user_agent = 'Crystal Bay Travel Integration/1.0'
            
        self.session = requests.Session()
    
    def _make_request(self, action: str, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """–í—ã–ø–æ–ª–Ω—è–µ—Ç –∑–∞–ø—Ä–æ—Å –∫ SAMO API - —Ç–æ—á–Ω–æ –∫–∞–∫ —Ä–∞–±–æ—Ç–∞—é—â–∏–π curl"""
        try:
            # –¢–û–ß–ù–û –ö–ê–ö –í –†–ê–ë–û–ß–ï–ú CURL - –≤—Å–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –≤ URL
            request_params = {
                'samo_action': 'api',
                'oauth_token': self.oauth_token,
                'type': 'json',
                'action': action
            }
            
            # –î–æ–±–∞–≤–ª—è–µ–º –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã
            if params is not None:
                request_params.update(params)
            
            import time
            start_time = time.time()
            
            # –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –∑–∞–ø—Ä–æ—Å–∞
            logger.info(f"=== SAMO API REQUEST START ===")
            logger.info(f"Action: {action}")
            logger.info(f"Method: POST")
            logger.info(f"URL: {self.base_url}")
            logger.info(f"Request Parameters: {request_params}")
            
            # Headers exactly like curl
            headers = {
                'User-Agent': 'curl/7.68.0',
                'Accept': '*/*'
            }
            logger.info(f"Request Headers: {headers}")
            
            # –°–æ–∑–¥–∞–µ–º –ø–æ–ª–Ω—ã–π URL –¥–ª—è –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
            from urllib.parse import urlencode
            full_url = f"{self.base_url}?{urlencode(request_params)}"
            logger.info(f"Full URL: {full_url}")
            
            # –í–ê–ñ–ù–û: –∏—Å–ø–æ–ª—å–∑—É–µ–º POST –∫–∞–∫ –≤ —Ä–∞–±–æ—á–µ–º curl
            response = self.session.post(self.base_url, params=request_params, headers=headers, timeout=self.timeout)
            
            request_time = time.time() - start_time
            
            # –î–µ—Ç–∞–ª—å–Ω–æ–µ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –æ—Ç–≤–µ—Ç–∞
            logger.info(f"=== SAMO API RESPONSE ===")
            logger.info(f"HTTP Status: {response.status_code} {response.reason}")
            logger.info(f"Response Time: {request_time:.3f}s")
            logger.info(f"Response Headers: {dict(response.headers)}")
            logger.info(f"Response Size: {len(response.text)} bytes")
            logger.info(f"Content-Type: {response.headers.get('content-type', 'unknown')}")
            
            # –õ–æ–≥–∏—Ä—É–µ–º –ø–µ—Ä–≤—ã–µ 500 —Å–∏–º–≤–æ–ª–æ–≤ –æ—Ç–≤–µ—Ç–∞ –¥–ª—è –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
            response_preview = response.text[:500] if response.text else "(empty)"
            logger.info(f"Response Preview (first 500 chars): {response_preview}")
            
            # –û–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö —Å—Ç–∞—Ç—É—Å –∫–æ–¥–æ–≤ –±–µ–∑ raise_for_status –¥–ª—è –ª—É—á—à–µ–≥–æ –∫–æ–Ω—Ç—Ä–æ–ª—è
            if response.status_code == 200:
                try:
                    result = response.json()
                    data_info = ""
                    if isinstance(result, dict):
                        data_info = f"dict with {len(result)} keys: {list(result.keys())}"
                    elif isinstance(result, list):
                        data_info = f"list with {len(result)} items"
                    else:
                        data_info = f"type: {type(result)}"
                    
                    logger.info(f"‚úÖ JSON PARSE SUCCESS - {data_info}")
                    logger.info(f"=== SAMO API REQUEST END ===")
                    
                    return {
                        "success": True,
                        "data": result,
                        "status_code": 200,
                        "action": action,
                        "request_details": {
                            "url": full_url,
                            "method": "POST",
                            "headers": headers,
                            "params": request_params,
                            "response_time": f"{request_time:.3f}s",
                            "response_headers": dict(response.headers),
                            "response_size": len(response.text)
                        }
                    }
                except json.JSONDecodeError as je:
                    logger.error(f"‚ùå JSON PARSE ERROR: {je}")
                    logger.error(f"Raw response text: {response.text}")
                    logger.info(f"=== SAMO API REQUEST END (JSON ERROR) ===")
                    return {
                        "success": False,
                        "error": f"Invalid JSON response from SAMO API: {str(je)}",
                        "raw_response": response.text,
                        "status_code": 200,
                        "action": action,
                        "request_details": {
                            "url": full_url,
                            "method": "POST", 
                            "headers": headers,
                            "params": request_params,
                            "response_time": f"{request_time:.3f}s",
                            "response_headers": dict(response.headers),
                            "response_size": len(response.text)
                        }
                    }
            elif response.status_code == 403:
                error_text = response.text
                logger.error(f"‚ùå HTTP 403 FORBIDDEN")
                logger.error(f"Error response: {error_text}")
                
                # –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ IP –∏–∑ –æ—Ç–≤–µ—Ç–∞ –¥–ª—è –ª—É—á—à–µ–π –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∏
                blocked_ip = "Unknown"
                if "blacklisted address" in error_text:
                    import re
                    ip_match = re.search(r'blacklisted address (\d+\.\d+\.\d+\.\d+)', error_text)
                    blocked_ip = ip_match.group(1) if ip_match else "Unknown"
                    logger.error(f"üö´ DETECTED BLOCKED IP: {blocked_ip}")
                
                logger.info(f"=== SAMO API REQUEST END (403 ERROR) ===")
                
                return {
                    "success": False,
                    "error": f"IP {blocked_ip} blocked by SAMO API",
                    "raw_response": error_text,
                    "status_code": 403,
                    "action": action,
                    "blocked_ip": blocked_ip,
                    "request_details": {
                        "url": full_url,
                        "method": "POST",
                        "headers": headers,
                        "params": request_params,
                        "response_time": f"{request_time:.3f}s",
                        "response_headers": dict(response.headers),
                        "response_size": len(response.text)
                    }
                }
            elif response.status_code == 500:
                logger.error(f"‚ùå HTTP 500 INTERNAL SERVER ERROR")
                logger.error(f"Server error response: {response.text}")
                logger.info(f"=== SAMO API REQUEST END (500 ERROR) ===")
                return {
                    "success": False,
                    "error": "SAMO API Internal Server Error",
                    "raw_response": response.text,
                    "status_code": 500,
                    "action": action,
                    "help": "Check required parameters for this action",
                    "request_details": {
                        "url": full_url,
                        "method": "POST",
                        "headers": headers,
                        "params": request_params,
                        "response_time": f"{request_time:.3f}s",
                        "response_headers": dict(response.headers),
                        "response_size": len(response.text)
                    }
                }
            else:
                logger.error(f"‚ùå HTTP {response.status_code} {response.reason}")
                logger.error(f"Unexpected response: {response.text}")
                logger.info(f"=== SAMO API REQUEST END (ERROR {response.status_code}) ===")
                return {
                    "success": False,
                    "error": f"HTTP {response.status_code} {response.reason}",
                    "raw_response": response.text,
                    "status_code": response.status_code,
                    "action": action,
                    "request_details": {
                        "url": full_url,
                        "method": "POST",
                        "headers": headers,
                        "params": request_params,
                        "response_time": f"{request_time:.3f}s",
                        "response_headers": dict(response.headers),
                        "response_size": len(response.text)
                    }
                }
            
        except requests.RequestException as e:
            logger.error(f"SAMO API –æ—à–∏–±–∫–∞ –∑–∞–ø—Ä–æ—Å–∞ {action}: {e}")
            
            # –°—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω–∞—è –æ–±—Ä–∞–±–æ—Ç–∫–∞ –≤—Å–µ—Ö —Ç–∏–ø–æ–≤ –æ—à–∏–±–æ–∫
            error_response = {
                "success": False,
                "error": f"Network error: {str(e)}",
                "action": action,
                "url": self.base_url,
                "oauth_token_suffix": self.oauth_token[-4:] if self.oauth_token else "None",
                "error_type": type(e).__name__
            }
            
            if hasattr(e, 'response') and e.response:
                error_response.update({
                    "status_code": e.response.status_code,
                    "raw_response": e.response.text[:500] if e.response.text else "",
                    "response_headers": dict(e.response.headers)
                })
            else:
                error_response["status_code"] = 0  # Indicates network error
            
            return error_response
    
    # === –†–ê–ë–û–ß–ò–ô API –ú–ï–¢–û–î ===
    
    def test_api_connection(self) -> Dict[str, Any]:
        """–¢–µ—Å—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ API —Å –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏"""
        try:
            # –°–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏
            simple_params = {
                'samo_action': 'api',
                'oauth_token': self.oauth_token,
                'action': 'GetStates'  # –ü—Ä–æ—Å—Ç–æ–π action
            }
            
            logger.info(f"üß™ –¢–ï–°–¢ API CONNECTION: {simple_params}")
            response = self.session.get(self.base_url, params=simple_params, timeout=10)
            
            return {
                "success": response.status_code == 200,
                "status_code": response.status_code,
                "content_type": response.headers.get('content-type', 'unknown'),
                "response_size": len(response.text),
                "response_preview": response.text[:200],
                "test_type": "simple_connection"
            }
        except Exception as e:
            return {
                "success": False,
                "error": str(e),
                "test_type": "simple_connection"
            }

    def get_all_data(self) -> Dict[str, Any]:
        """–¢–ï–°–¢ –í–°–ï–• –í–û–ó–ú–û–ñ–ù–´–• –í–ê–†–ò–ê–ù–¢–û–í API –í–´–ó–û–í–ê"""
        logger.info("üîç –ù–ê–ß–ò–ù–ê–ï–ú –ü–û–õ–ù–£–Æ –î–ò–ê–ì–ù–û–°–¢–ò–ö–£ SAMO API")
        
        # –í–∞—Ä–∏–∞–Ω—Ç 1: GET –∑–∞–ø—Ä–æ—Å (–∫–∞–∫ –º–Ω–æ–≥–∏–µ API —Ä–∞–±–æ—Ç–∞—é—Ç)
        try:
            logger.info("=== –¢–ï–°–¢ 1: GET –∑–∞–ø—Ä–æ—Å ===")
            get_params = {
                'samo_action': 'api',
                'oauth_token': self.oauth_token,
                'type': 'json',
                'action': 'SearchTour_ALL'
            }
            response1 = self.session.get(self.base_url, params=get_params, timeout=10)
            logger.info(f"GET —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {response1.status_code}, Content-Type: {response1.headers.get('content-type')}")
            if response1.status_code == 200 and 'application/json' in response1.headers.get('content-type', ''):
                return {"success": True, "method": "GET", "data": response1.json()}
        except Exception as e:
            logger.info(f"GET –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")
            
        # –í–∞—Ä–∏–∞–Ω—Ç 2: POST —Å –¥–∞–Ω–Ω—ã–º–∏ –≤ body
        try:
            logger.info("=== –¢–ï–°–¢ 2: POST —Å –¥–∞–Ω–Ω—ã–º–∏ –≤ body ===")
            post_data = {
                'samo_action': 'api',
                'oauth_token': self.oauth_token,
                'type': 'json',
                'action': 'SearchTour_ALL'
            }
            response2 = self.session.post(self.base_url, data=post_data, timeout=10)
            logger.info(f"POST body —Ä–µ–∑—É–ª—å—Ç–∞—Ç: {response2.status_code}, Content-Type: {response2.headers.get('content-type')}")
            if response2.status_code == 200 and 'application/json' in response2.headers.get('content-type', ''):
                return {"success": True, "method": "POST_BODY", "data": response2.json()}
        except Exception as e:
            logger.info(f"POST body –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")
            
        # –í–∞—Ä–∏–∞–Ω—Ç 3: –ü—Ä–æ—Å—Ç–µ–π—à–∏–π —Ç–µ—Å—Ç –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è
        try:
            logger.info("=== –¢–ï–°–¢ 3: –ü—Ä–æ—Å—Ç–µ–π—à–∏–π API —Ç–µ—Å—Ç ===")
            simple_params = {
                'samo_action': 'api',
                'oauth_token': self.oauth_token,
                'type': 'json',
                'action': 'GetStates'  # –°–∞–º—ã–π –ø—Ä–æ—Å—Ç–æ–π action
            }
            response3 = self.session.get(self.base_url, params=simple_params, timeout=10)
            logger.info(f"–ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç: {response3.status_code}, Content-Type: {response3.headers.get('content-type')}")
            logger.info(f"–û—Ç–≤–µ—Ç: {response3.text[:200]}")
            
            if response3.status_code == 200:
                return {
                    "success": True, 
                    "method": "SIMPLE_TEST", 
                    "working_endpoint": True,
                    "response": response3.text[:500]
                }
        except Exception as e:
            logger.info(f"–ü—Ä–æ—Å—Ç–æ–π —Ç–µ—Å—Ç –Ω–µ —Å—Ä–∞–±–æ—Ç–∞–ª: {e}")
            
        # –í–æ–∑–≤—Ä–∞—â–∞–µ–º –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É
        return {
            "success": False,
            "error": "–í–°–ï –ú–ï–¢–û–î–´ –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–Ø –ù–ï –°–†–ê–ë–û–¢–ê–õ–ò",
            "action": "FULL_DIAGNOSTIC",
            "recommendation": "–ù—É–∂–Ω–æ —Å–≤—è–∑–∞—Ç—å—Å—è —Å —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–æ–π SAMO API"
        }
    
    # === –ü–û–ò–°–ö –¢–£–†–û–í ===
    
    def search_tour_prices(self, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """–ü–æ–∏—Å–∫ —Ü–µ–Ω –Ω–∞ —Ç—É—Ä—ã - –ø—Ä—è–º–æ–π –≤—ã–∑–æ–≤ –∫–∞–∫ curl"""
        try:
            # –ë–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã —Ç–æ—á–Ω–æ –∫–∞–∫ –≤ —Ä–∞–±–æ—á–µ–º curl
            request_params = {
                'samo_action': 'api',
                'oauth_token': self.oauth_token,
                'type': 'json',
                'action': 'SearchTour_PRICES'
            }
            
            # –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞ –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω—ã
            if params:
                # –ú–∞–ø–ø–∏–Ω–≥ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç SAMO API
                if 'townfrom' in params:
                    request_params['TOWNFROMINC'] = params['townfrom']
                if 'stateinc' in params:
                    request_params['STATEINC'] = params['stateinc']
                if 'checkin' in params:
                    request_params['CHECKIN_BEG'] = params['checkin']
                if 'checkout' in params:
                    request_params['CHECKIN_END'] = params['checkout']
                if 'nights' in params:
                    request_params['NIGHTS_FROM'] = params['nights']
                    request_params['NIGHTS_TILL'] = params['nights']
                if 'adults' in params:
                    request_params['ADULT'] = params['adults']
                if 'children' in params:
                    request_params['CHILD'] = params['children']
                if 'currency' in params:
                    request_params['CURRENCY'] = params['currency']
            
            logger.info(f"SAMO SearchTour_PRICES request: {request_params}")
            
            # –ü—Ä—è–º–æ–π GET –∑–∞–ø—Ä–æ—Å –∫–∞–∫ curl
            response = self.session.get(self.base_url, params=request_params, timeout=30)
            
            logger.info(f"Search prices response: {response.status_code}")
            logger.info(f"Response content type: {response.headers.get('content-type')}")
            
            if response.status_code == 200:
                try:
                    if 'application/json' in response.headers.get('content-type', ''):
                        data = response.json()
                        return {"success": True, "data": data, "action": "SearchTour_PRICES"}
                    else:
                        # HTML –∏–ª–∏ —Ç–µ–∫—Å—Ç –æ—Ç–≤–µ—Ç
                        return {
                            "success": True,
                            "data": {"raw_response": response.text},
                            "action": "SearchTour_PRICES",
                            "content_type": response.headers.get('content-type')
                        }
                except Exception as e:
                    return {
                        "success": False,
                        "error": f"JSON parse error: {e}",
                        "raw_response": response.text[:500]
                    }
            else:
                return handle_error_response(response, "SearchTour_PRICES")
                
        except Exception as e:
            logger.error(f"Search prices error: {e}")
            return {"success": False, "error": str(e)}

    def search_tour_all(self, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """SearchTour_ALL method for API compatibility"""
        return self.search_tours_detailed(params)
    
    def search_tours_detailed(self, params: Optional[Dict[str, Any]] = None) -> Dict[str, Any]:
        """–î–µ—Ç–∞–ª—å–Ω—ã–π –ø–æ–∏—Å–∫ —Ç—É—Ä–æ–≤ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º SearchTour_ALL - —Ä–∞–±–æ—á–∏–π –º–µ—Ç–æ–¥"""
        try:
            # –ë–∞–∑–æ–≤—ã–µ –ø–∞—Ä–∞–º–µ—Ç—Ä—ã - –¢–û–ß–ù–û –∫–∞–∫ –≤ —Ä–∞–±–æ—Ç–∞—é—â–µ–º production curl
            request_params = {
                'samo_action': 'api',
                'oauth_token': self.oauth_token,
                'type': 'json',
                'action': 'SearchTour_ALL'
            }
            
            # –î–æ–±–∞–≤–ª—è–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ–∏—Å–∫–∞ –µ—Å–ª–∏ –ø–µ—Ä–µ–¥–∞–Ω—ã
            if params:
                # –ú–∞–ø–ø–∏–Ω–≥ –ø–∞—Ä–∞–º–µ—Ç—Ä–æ–≤ –≤ —Ñ–æ—Ä–º–∞—Ç SAMO API
                if 'townFrom' in params or 'townfrom' in params:
                    townfrom = params.get('townFrom') or params.get('townfrom')
                    if townfrom:
                        request_params['TOWNFROMINC'] = townfrom
                
                if 'countryTo' in params or 'country' in params:
                    country = params.get('countryTo') or params.get('country')
                    if country:
                        request_params['STATEINC'] = country
                
                if 'checkIn' in params:
                    request_params['CHECKIN_BEG'] = params['checkIn']
                
                if 'nights' in params and params['nights']:
                    nights = str(params['nights'])
                    request_params['NIGHTS_FROM'] = nights
                    request_params['NIGHTS_TILL'] = nights
                
                if 'adults' in params and params['adults']:
                    request_params['ADULT'] = str(params['adults'])
                
                if 'children' in params and params['children']:
                    request_params['CHILD'] = str(params['children'])
                
                if 'stars' in params and params['stars']:
                    request_params['STARS'] = str(params['stars'])
                
                if 'meal' in params and params['meal']:
                    request_params['MEAL'] = params['meal']
                
                if 'priceFrom' in params and params['priceFrom']:
                    request_params['PRICE_FROM'] = str(params['priceFrom'])
                
                if 'priceTo' in params and params['priceTo']:
                    request_params['PRICE_TO'] = str(params['priceTo'])
            
            logger.info(f"=== DETAILED TOUR SEARCH START ===")
            logger.info(f"Search parameters: {params}")
            logger.info(f"SAMO API parameters: {request_params}")
            
            # –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø—Ä—è–º–æ–π POST –∫–∞–∫ –≤ —Ä–∞–±–æ—á–µ–º curl
            import time
            start_time = time.time()
            
            response = requests.post(
                self.base_url,
                params=request_params,
                headers={
                    'User-Agent': self.user_agent,
                    'Accept': 'application/json',
                    'Content-Type': 'application/x-www-form-urlencoded'
                },
                timeout=30
            )
            
            request_time = time.time() - start_time
            
            logger.info(f"Search response: HTTP {response.status_code}")
            logger.info(f"Response time: {request_time:.3f}s")
            logger.info(f"Response size: {len(response.text)} bytes")
            logger.info(f"Content-Type: {response.headers.get('content-type')}")
            
            if response.status_code == 200:
                try:
                    if len(response.text) > 0:
                        # –ü–æ–ø—ã—Ç–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ JSON
                        if 'application/json' in response.headers.get('content-type', ''):
                            data = response.json()
                            logger.info(f"‚úÖ JSON parsed successfully, keys: {list(data.keys()) if isinstance(data, dict) else 'not dict'}")
                            return {
                                "success": True,
                                "data": data,
                                "action": "SearchTour_ALL",
                                "search_params": params,
                                "request_details": {
                                    "url": self.base_url,
                                    "method": "POST",
                                    "params": request_params,
                                    "response_time": f"{request_time:.3f}s",
                                    "response_size": len(response.text)
                                }
                            }
                        else:
                            # HTML –∏–ª–∏ —Ç–µ–∫—Å—Ç–æ–≤—ã–π –æ—Ç–≤–µ—Ç - –≤–æ–∑–º–æ–∂–Ω–æ –¥–∞–Ω–Ω—ã–µ –≤ –¥—Ä—É–≥–æ–º —Ñ–æ—Ä–º–∞—Ç–µ
                            logger.info("‚ö†Ô∏è Non-JSON response, treating as raw data")
                            return {
                                "success": True,
                                "data": {"raw_response": response.text[:1000]},
                                "action": "SearchTour_ALL",
                                "search_params": params,
                                "content_type": response.headers.get('content-type'),
                                "note": "Non-JSON response format"
                            }
                    else:
                        logger.error("‚ùå Empty response body")
                        return {
                            "success": False,
                            "error": "Empty response from SAMO API",
                            "action": "SearchTour_ALL",
                            "search_params": params,
                            "help": "Check OAuth token and API parameters"
                        }
                        
                except json.JSONDecodeError as e:
                    logger.error(f"JSON decode error: {e}")
                    return {
                        "success": False,
                        "error": f"Invalid JSON response: {e}",
                        "raw_response": response.text[:500],
                        "action": "SearchTour_ALL"
                    }
            else:
                logger.error(f"‚ùå HTTP {response.status_code} error")
                return handle_error_response(response, "SearchTour_ALL")
                
        except Exception as e:
            logger.error(f"Detailed search error: {e}")
            return {
                "success": False,
                "error": str(e),
                "action": "SearchTour_ALL",
                "search_params": params or {}
            }
    
    # === –ë–†–û–ù–ò–†–û–í–ê–ù–ò–ï ===
    
    def get_orders_api(self, date_from: Optional[str] = None, date_to: Optional[str] = None) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞—è–≤–æ–∫ —á–µ—Ä–µ–∑ ClaimSearch WebAPI"""
        if date_from is None:
            date_from = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
        if date_to is None:
            date_to = datetime.now().strftime('%Y-%m-%d')
            
        try:
            # ClaimSearch –∏—Å–ø–æ–ª—å–∑—É–µ—Ç WebAPI, –∞ –Ω–µ –æ–±—ã—á–Ω—ã–π SAMO API
            webapi_baseurl = "https://booking.crystalbay.com"
            url = f"{webapi_baseurl}/MyOffice/ClaimSearch"
            
            # –ü–∞—Ä–∞–º–µ—Ç—Ä—ã –¥–ª—è ClaimSearch (OData style)
            params = {
                '$orderBy': 'inc desc',
                'lang': 'ru',
                'skip': 0,
                'take': 100,
                'xdebug': 'true'
            }
            
            # –§–∏–ª—å—Ç—Ä –ø–æ –¥–∞—Ç–µ —Å–æ–∑–¥–∞–Ω–∏—è
            if date_from and date_to:
                params['$filter'] = f"cDate ge {date_from}T00:00:00z and cDate le {date_to}T23:59:59z"
            elif date_from:
                params['$filter'] = f"cDate ge {date_from}T00:00:00z"
            
            # –ó–∞–≥–æ–ª–æ–≤–∫–∏ –¥–ª—è WebAPI (Bearer —Ç–æ–∫–µ–Ω)
            headers = {
                'Authorization': f'Bearer {self.oauth_token}',
                'Accept': 'application/json',
                'User-Agent': 'Crystal Bay Travel/1.0'
            }
            
            logger.info("=== CLAIMSEARCH API REQUEST START ===")
            logger.info(f"Action: ClaimSearch")
            logger.info(f"Method: GET")
            logger.info(f"URL: {url}")
            logger.info(f"Parameters: {params}")
            logger.info(f"Headers: {headers}")
            
            response = requests.get(url, params=params, headers=headers, timeout=30)
            
            logger.info("=== CLAIMSEARCH API RESPONSE ===")
            logger.info(f"HTTP Status: {response.status_code} {response.reason}")
            logger.info(f"Response Headers: {dict(response.headers)}")
            
            if response.status_code == 200:
                try:
                    data = response.json()
                    logger.info(f"‚úÖ ClaimSearch —É—Å–ø–µ—à–Ω–æ: –ø–æ–ª—É—á–µ–Ω–æ {len(data) if isinstance(data, list) else 1} –∑–∞—è–≤–æ–∫")
                    return {
                        'success': True,
                        'data': {'ClaimSearch': data if isinstance(data, list) else [data]},
                        'total': len(data) if isinstance(data, list) else 1,
                        'source': 'CLAIMSEARCH_WEBAPI'
                    }
                except Exception as e:
                    logger.error(f"ClaimSearch JSON parse error: {e}")
                    return {
                        'success': False,
                        'error': f'JSON parse error: {e}',
                        'raw_response': response.text[:500]
                    }
            elif response.status_code == 403:
                logger.error("‚ùå ClaimSearch: –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω (Bearer —Ç–æ–∫–µ–Ω)")
                return {
                    'success': False,
                    'error': 'ClaimSearch API –¥–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â–µ–Ω (Bearer —Ç–æ–∫–µ–Ω –Ω–µ–≤–µ—Ä–Ω—ã–π)'
                }
            else:
                logger.error(f"‚ùå ClaimSearch HTTP {response.status_code}")
                return {
                    'success': False,
                    'error': f'ClaimSearch HTTP {response.status_code}: {response.text[:200]}'
                }
                
        except Exception as e:
            logger.error(f"ClaimSearch API error: {e}")
            return {
                'success': False,
                'error': str(e)
            }

    def get_bookings_api(self, date_from: Optional[str] = None, date_to: Optional[str] = None) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π —á–µ—Ä–µ–∑ API"""
        if date_from is None:
            date_from = (datetime.now() - timedelta(days=30)).strftime('%Y-%m-%d')
        if date_to is None:
            date_to = datetime.now().strftime('%Y-%m-%d')
            
        params = {
            'date_from': date_from,
            'date_to': date_to
        }
        
        return self._make_request('GetBookings', params)
    
    def get_booking_details(self, booking_id: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–µ—Ç–∞–ª–∏ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏—è"""
        params = {'booking_id': booking_id}
        return self._make_request('GetBookingDetails', params)
    
    def create_booking(self, booking_data: Dict[str, Any]) -> Dict[str, Any]:
        """–°–æ–∑–¥–∞—Ç—å –Ω–æ–≤–æ–µ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ"""
        return self._make_request('CreateBooking', booking_data)
    
    def update_booking(self, booking_id: str, booking_data: Dict[str, Any]) -> Dict[str, Any]:
        """–û–±–Ω–æ–≤–∏—Ç—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ"""
        params = {'booking_id': booking_id}
        params.update(booking_data)
        return self._make_request('UpdateBooking', params)
    
    def cancel_booking(self, booking_id: str, reason: str = "") -> Dict[str, Any]:
        """–û—Ç–º–µ–Ω–∏—Ç—å –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ"""
        params = {
            'booking_id': booking_id,
            'cancel_reason': reason
        }
        return self._make_request('CancelBooking', params)
    
    # === –ö–õ–ò–ï–ù–¢–´ ===
    
    def create_person(self, person_data: Dict[str, Any]) -> Dict[str, Any]:
        """–°–æ–∑–¥–∞—Ç—å –∫–ª–∏–µ–Ω—Ç–∞"""
        return self._make_request('Person_Create', person_data)
    
    def update_person(self, person_id: str, person_data: Dict[str, Any]) -> Dict[str, Any]:
        """–û–±–Ω–æ–≤–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∫–ª–∏–µ–Ω—Ç–∞"""
        params = {'person_id': person_id}
        params.update(person_data)
        return self._make_request('Person_Update', params)
    
    def get_person(self, person_id: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–∞–Ω–Ω—ã–µ –∫–ª–∏–µ–Ω—Ç–∞"""
        params = {'person_id': person_id}
        return self._make_request('Person_Get', params)
    
    # === –û–¢–ß–ï–¢–´ ===
    
    def get_sales_report(self, date_from: str, date_to: str) -> Dict[str, Any]:
        """–û—Ç—á–µ—Ç –ø–æ –ø—Ä–æ–¥–∞–∂–∞–º"""
        params = {
            'date_from': date_from,
            'date_to': date_to
        }
        return self._make_request('Report_Sales', params)
    
    def get_financial_report(self, date_from: str, date_to: str) -> Dict[str, Any]:
        """–§–∏–Ω–∞–Ω—Å–æ–≤—ã–π –æ—Ç—á–µ—Ç"""
        params = {
            'date_from': date_from,
            'date_to': date_to
        }
        return self._make_request('Report_Financial', params)
    
    # === –î–û–ü–û–õ–ù–ò–¢–ï–õ–¨–ù–´–ï –£–°–õ–£–ì–ò ===
    
    def get_services(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—ã–µ —É—Å–ª—É–≥–∏"""
        return self._make_request('Services_Get')
    
    def book_service(self, service_data: Dict[str, Any]) -> Dict[str, Any]:
        """–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –¥–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω—É—é —É—Å–ª—É–≥—É"""
        return self._make_request('Services_Book', service_data)
    
    # === –°–¢–†–ê–•–û–í–ö–ò ===
    
    def get_insurance_types(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Ç–∏–ø—ã —Å—Ç—Ä–∞—Ö–æ–≤–æ–∫"""
        return self._make_request('Insurance_GetTypes')
    
    def calculate_insurance(self, insurance_data: Dict[str, Any]) -> Dict[str, Any]:
        """–†–∞—Å—Å—á–∏—Ç–∞—Ç—å —Å—Ç–æ–∏–º–æ—Å—Ç—å —Å—Ç—Ä–∞—Ö–æ–≤–∫–∏"""
        return self._make_request('Insurance_Calculate', insurance_data)
    
    def book_insurance(self, insurance_data: Dict[str, Any]) -> Dict[str, Any]:
        """–ó–∞–±—Ä–æ–Ω–∏—Ä–æ–≤–∞—Ç—å —Å—Ç—Ä–∞—Ö–æ–≤–∫—É"""
        return self._make_request('Insurance_Book', insurance_data)
    
    # === –ü–õ–ê–¢–ï–ñ–ò ===
    
    def get_payment_methods(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–æ—Å–æ–±—ã –æ–ø–ª–∞—Ç—ã"""
        return self._make_request('Payment_GetMethods')
    
    def create_payment(self, payment_data: Dict[str, Any]) -> Dict[str, Any]:
        """–°–æ–∑–¥–∞—Ç—å –ø–ª–∞—Ç–µ–∂"""
        return self._make_request('Payment_Create', payment_data)
    
    def get_payment_status(self, payment_id: str) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞"""
        params = {'payment_id': payment_id}
        return self._make_request('Payment_GetStatus', params)
    
    # === –£–í–ï–î–û–ú–õ–ï–ù–ò–Ø ===
    
    def get_notifications(self) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è"""
        return self._make_request('Notifications_Get')
    
    def mark_notification_read(self, notification_id: str) -> Dict[str, Any]:
        """–û—Ç–º–µ—Ç–∏—Ç—å —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –∫–∞–∫ –ø—Ä–æ—á–∏—Ç–∞–Ω–Ω–æ–µ"""
        params = {'notification_id': notification_id}
        return self._make_request('Notifications_MarkRead', params)
    
    # === –¢–ï–°–¢–ò–†–û–í–ê–ù–ò–ï –ü–û–î–ö–õ–Æ–ß–ï–ù–ò–Ø ===
    
    def test_connection(self) -> Dict[str, Any]:
        """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ API"""
        try:
            # –ü—Ä–æ—Å—Ç–æ–π –∑–∞–ø—Ä–æ—Å –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ API
            result = self.get_all_data()
            
            if 'error' in result:
                return {
                    'success': False,
                    'message': f"–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {result.get('error', '–ù–µ–∏–∑–≤–µ—Å—Ç–Ω–∞—è –æ—à–∏–±–∫–∞')}",
                    'details': result
                }
            
            return {
                'success': True,
                'message': "–ü–æ–¥–∫–ª—é—á–µ–Ω–∏–µ –∫ SAMO API —É—Å–ø–µ—à–Ω–æ",
                'api_version': "1.0",
                'endpoint': self.base_url
            }
            
        except Exception as e:
            return {
                'success': False,
                'message': f"–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è: {str(e)}"
            }

    def get_bookings(self, date_from: Optional[str] = None, date_to: Optional[str] = None, 
                     status: Optional[str] = None, limit: int = 100) -> Dict[str, Any]:
        """–ü–æ–ª—É—á–∏—Ç—å —Å–ø–∏—Å–æ–∫ –±—Ä–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–π (production - –±–µ–∑ –¥–µ–º–æ-–¥–∞–Ω–Ω—ã—Ö)"""
        try:
            # –ü—Ä–æ–±—É–µ–º –ø–æ–ª—É—á–∏—Ç—å —Å–ø—Ä–∞–≤–æ—á–Ω–∏–∫–∏ –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ API
            townfroms = self.get_all_data()
            
            if 'error' not in townfroms:
                # API –¥–æ—Å—Ç—É–ø–µ–Ω, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Ä–µ–∑—É–ª—å—Ç–∞—Ç –¥–ª—è –ø—Ä–æ–¥–∞–∫—à–Ω
                # Production: No demo data, return empty result
                return {'bookings': [], 'total': 0}
            else:
                return {'error': townfroms.get('error', 'API –Ω–µ–¥–æ—Å—Ç—É–ø–µ–Ω')}
                
        except Exception as e:
            return {'error': str(e)}
    
    def _create_demo_bookings(self) -> List[Dict]:
        """Production: All demo data removed"""
        return []

# –ì–ª–æ–±–∞–ª—å–Ω—ã–π —ç–∫–∑–µ–º–ø–ª—è—Ä API
crystal_bay_api = CrystalBaySamoAPI()

def get_crystal_bay_api() -> CrystalBaySamoAPI:
    """–ü–æ–ª—É—á–∏—Ç—å —ç–∫–∑–µ–º–ø–ª—è—Ä Crystal Bay SAMO API"""
    return crystal_bay_api


def test_samo_api_connection():
    """–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è –∫ SAMO API"""
    try:
        api = get_crystal_bay_api()
        result = api.test_connection()
        return result
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è SAMO API: {e}")
        return {
            'success': False, 
            'message': f'–û—à–∏–±–∫–∞ –ø–æ–¥–∫–ª—é—á–µ–Ω–∏—è: {str(e)}',
            'details': '–ü—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ SAMO API –∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç—å —Å–µ—Ä–≤–µ—Ä–∞'
        }